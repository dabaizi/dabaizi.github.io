<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博观约取 厚积薄发 知人者智 自知者明；胜人者力 自胜者强"><title>【C++基础】const相关 | 博观约取 厚积薄发</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【C++基础】const相关</h1><a id="logo" href="/.">博观约取 厚积薄发</a><p class="description">知人者智 自知者明；胜人者力 自胜者强</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【C++基础】const相关</h1><div class="post-meta">Apr 27, 2016</div><div class="post-content"><p>const的作用可以定义const常量，如：const int N = 10，常量不可修改，便于进行类型检查，const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误，如：void f(const int i){…}//对传入的参数进行类型检查，不匹配进行提示等等<br><a id="more"></a></p>
<h3 id="const的作用"><a href="#const的作用" class="headerlink" title="const的作用"></a>const的作用</h3><p>1、可以定义const常量，如：const int N = 10，常量不可修改</p>
<p>2、便于进行类型检查，const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误，如：void f(const int i){…}//对传入的参数进行类型检查，不匹配进行提示</p>
<p>3、保护被修饰内容，如void f(const int i){…}//方法里面不可对i进行修改，如果修改了，如i=1;则会报错</p>
<p>4、节省空间，避免不必要的内存分配，const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝</p>
<p>5、提高效率，编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高</p>
<h3 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h3><p>1、定义常量：const修饰的类型为T的变量值是不可变的，如：int const i = 1; const int i = 1;这两种写法的效果是一样的</p>
<p>2、const与指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* <span class="keyword">const</span> pContent; <span class="comment">//指针本身是常量不可变</span></div><div class="line"> </div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pContent; <span class="comment">//指针所指向的内容是常量不可变</span></div><div class="line"> </div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> pContent; <span class="comment">//指针所指向的内容是常量不可变</span></div></pre></td></tr></table></figure>
<p>如果const位于<em>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于</em>的右侧，const就是修饰指针本身，即指针本身是常量。</p>
<p>3、函数中的const：函数中用到const主要有三种情况，修饰函数参数，修饰函数返回值，修饰函数this指针</p>
<p>const修饰函数参数，无非就是禁止在函数内对参数进行修改</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void <span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">const</span> int <span class="keyword">Var</span>)</span>;</span><span class="comment">//传递过来的参数在函数内不可以改变</span></div><div class="line"> </div><div class="line">void <span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">const</span> char* <span class="keyword">Var</span>)</span>;</span><span class="comment">//参数指针所指内容为常量不可变</span></div><div class="line"> </div><div class="line">void <span class="function"><span class="keyword">function</span><span class="params">(char* <span class="keyword">const</span> <span class="keyword">Var</span>)</span>;</span><span class="comment">//参数指针本身为常量不可变</span></div><div class="line"> </div><div class="line">void <span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">Class</span>&amp; <span class="keyword">Var</span>)</span>;</span> <span class="comment">//引用参数在函数内不可以改变</span></div><div class="line"> </div><div class="line">void <span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">TYPE</span>&amp; <span class="keyword">Var</span>)</span>;</span> <span class="comment">//引用参数在函数内为常量不可变</span></div></pre></td></tr></table></figure>
<p>const 修饰函数返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span></span>; <span class="comment">//这个其实无意义，因为参数返回本身就是赋值。</span></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="title">fun2</span><span class="params">()</span></span>; <span class="comment">//调用时 const int *pValue = fun2(); </span></div><div class="line">                          <span class="comment">//我们可以把fun2()看作成一个变量，即指针内容不可变。</span></div><div class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">fun3</span><span class="params">()</span></span>;<span class="comment">//调用时 int * const pValue = fun2(); </span></div><div class="line">                          <span class="comment">//我们可以把fun2()看作成一个变量，即指针本身不可变。</span></div></pre></td></tr></table></figure>
<p>一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A&amp; test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。</p>
<p>修饰类this指针：这种情况下，一般用在某个类中，将方法声明称 void f() const;这个const修饰的是该类的this指针，把this声明称const，在该类中，禁止对该类中任何数据成员进行修改，只能读取，不能写入。</p>
<h3 id="const与类"><a href="#const与类" class="headerlink" title="const与类"></a>const与类</h3><p>1、const修饰成员变量：const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123; </div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="keyword">const</span> <span class="keyword">int</span> nValue;         <span class="comment">//成员常量不能被修改</span></div><div class="line">   A(<span class="keyword">int</span> x): nValue(x) &#123; &#125; ; <span class="comment">//只能在初始化列表中赋值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、const修饰成员函数：const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数，如上所说，修饰的是类的this指针，也不能调用类中任何非const成员函数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">void</span> <span class="function"><span class="keyword">function</span><span class="params">()</span><span class="title">const</span></span>; <span class="comment">//常成员函数, 它不改变对象的成员变量</span></div><div class="line">             <span class="comment">//也不能调用类中任何非const成员函数。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>a. const成员函数不被允许修改它所在对象的任何一个数据成员。

b. const成员函数能够访问对象的const成员，而其他成员函数不可以。
</code></pre><p>3、const修饰类对象/对象指针/对象引用</p>
<pre><code>· const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。

· const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。
</code></pre><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class<span class="built_in"> AAA</span></div><div class="line">&#123; </div><div class="line">    void func1(); </div><div class="line">    void func2() const; </div><div class="line">&#125; </div><div class="line">const<span class="built_in"> AAA </span>aObj; </div><div class="line">aObj.func1(); ×</div><div class="line">aObj.func2(); 正确</div><div class="line"> </div><div class="line">const AAA* aObj = new AAA(); </div><div class="line">aObj-&gt; func1(); ×</div><div class="line">aObj-&gt; func2(); 正确</div></pre></td></tr></table></figure>
<h3 id="const与非const之间的转换"><a href="#const与非const之间的转换" class="headerlink" title="const与非const之间的转换"></a>const与非const之间的转换</h3><p>采用const_cast 进行转换。<br>用法：const_cast <type_id> (expression)<br>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。</type_id></p>
<p>· 常量指针被转化成非常量指针，并且仍然指向原来的对象；</p>
<p>· 常量引用被转换成非常量引用，并且仍然指向原来的对象；</p>
<p>· 常量对象被转换成非常量对象。</p>
<p>其他：</p>
<p>如何初始化类内部的常量：一种方法就是static 和 const 并用，在外部初始化，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></div><div class="line">&#123; </div><div class="line"><span class="keyword">public</span>: </div><div class="line">    A() &#123;&#125;</div><div class="line"><span class="keyword">private</span>: </div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> i; <span class="comment">//注意必须是静态的！</span></div><div class="line"> &#125;；</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> A::i=<span class="number">3</span>;</div></pre></td></tr></table></figure>
<p>另一个很常见的方法就是初始化列表：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">class</span> <span class="selector-tag">A</span> </div><div class="line">&#123; </div><div class="line"><span class="attribute">public</span>: </div><div class="line">    <span class="built_in">A</span>(int i=0):<span class="built_in">test</span>(i) &#123;&#125; </div><div class="line"><span class="selector-tag">private</span>: </div><div class="line">    <span class="selector-tag">const</span> <span class="selector-tag">int</span> <span class="selector-tag">test</span>; </div><div class="line">&#125;；</div></pre></td></tr></table></figure></p>
</div><div class="tags"></div><div class="post-nav"><a href="/2016/04/29/cplusplus-foundation-6/" class="pre">【C++基础】虚函数与继承</a><a href="/2016/04/26/cplusplus-foundation-4/" class="next">【C++基础】函数指针</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://dabaizi.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/18/learn-algorithm-6/">【渣渣学算法6】Font Size</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/17/learn-algorithm-5/">【渣渣学算法5】Hangover</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/12/learn-algorithm-4/">【渣渣学算法4】487-3279</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/11/learn-algorithm-3/">【渣渣学算法3】Exponentiation</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/10/learn-algorithm-2/">【渣渣学算法2】最长回文子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/07/learn-algorithm-1/">【渣渣学算法1】之传话游戏</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/30/cplusplus-foundation-7/">【C++基础】矩阵模板类</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/29/cplusplus-foundation-6/">【C++基础】虚函数与继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/27/cplusplus-foundation-5/">【C++基础】const相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/26/cplusplus-foundation-4/">【C++基础】函数指针</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.aligugu.net/" title="阿里姑姑" target="_blank">阿里姑姑</a><ul></ul><a href="http://www.uxhr.com/" title="优秀hr" target="_blank">优秀hr</a><ul></ul><a href="http://www.example3.com/" title="米表" target="_blank">米表</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">博观约取 厚积薄发.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>