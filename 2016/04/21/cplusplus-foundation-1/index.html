<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博观约取 厚积薄发 知人者智 自知者明；胜人者力 自胜者强"><title>【C++基础】线程基础 | 博观约取 厚积薄发</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【C++基础】线程基础</h1><a id="logo" href="/.">博观约取 厚积薄发</a><p class="description">知人者智 自知者明；胜人者力 自胜者强</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【C++基础】线程基础</h1><div class="post-meta">Apr 21, 2016</div><div class="post-content"><p>线程基础：线程，可称为轻量级进程，是程序执行流的最小单元，一个标准的线程→线程的ID、当前的指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程是优多个线程组成的，各个线程之间共享程序的内存空间（代码段、数据段、堆等）以及一些进程级的资源（比如打开文件和信号）。<br><a id="more"></a></p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>原子操作：单指令的操作称为原子操作，单条指令的执行时不会被打断的。为了避免出错，很多体系结构都提供了一些常用操作的原子指令。有一些C++的库，也提供了一些原子操作的方法，可以将特定的操作封装成原子操作。</p>
<p>同步与锁：所谓同步，就是一个线程访问数据未结束之前，其他数据不得对同一个数据进行访问，如此一来，对这个数据的访问就被原子化了。</p>
<p>一个线程不同步的例子：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个不同步的多线程程序</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="keyword">long</span> iSum = <span class="number">0</span>;</div><div class="line"><span class="keyword">void</span> test()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</div><div class="line">    &#123;</div><div class="line">        iSum++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    std::thread th1(test), th2(test), th3(test);</div><div class="line">    th1.join();</div><div class="line">    th2.join();</div><div class="line">    th3.join();</div><div class="line">    std::cout &lt;&lt; <span class="string">"Sum :"</span> &lt;&lt; iSum &lt;&lt; std::endl;</div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="built_in">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义了三个线程，都对同一个共享变量iSum进行操作，iSum的初始值是0，每个线程加100000（这个值需要足够大），三个线程，预期的结果应该是30W，而实际上，每次运行的结果都不一致。解决这种多线程中不同步的方式有以下几种：信号量、互斥量、临界区、读写锁以及条件变量</p>
<p>信号量是一种同步机制，其中二元信号量就是一种最简单的锁，只有两种状态，占用和非占用。对于多线程并发的资源，可以使用多元信号量，多元信号量简称信号量。一个初始值为N的信号量允许N个线程并发访问，一个线程访问资源时，首先获取信号量，具体操作如下：</p>
<ul>
<li>将信号量减1</li>
<li>如果信号量的值小于0，则进入等待状态，否则将继续进行</li>
</ul>
<p>访问完成后，线程释放信号量：</p>
<ul>
<li>将信号量的值加1</li>
<li>如果信号量的值小于1，唤醒一个等待中的线程。</li>
</ul>
<p>互斥量和二元信号量类似，每次只允许一个线程访问资源。和信号量不同的是，信号量在整个系统中可以被任何其他线程获取并释放，同一个信号量可以在整个系统中由一个线程获取后，再由另外一个线程释放。而互斥量则要求哪个线程获取了信号量，哪个线程就要负责释放这个信号量。</p>
<p>互斥量例子：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="keyword">long</span> iSum = <span class="number">0</span>;</div><div class="line">std::mutex m;   <span class="comment">//互斥量</span></div><div class="line"><span class="keyword">void</span> test_mutex()</div><div class="line">&#123;</div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</div><div class="line">    &#123;</div><div class="line">        m.lock();</div><div class="line">        iSum++;</div><div class="line">        m.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    std::thread th1(test_mutex), th2(test_mutex), th3(test_mutex);</div><div class="line">    th1.join();</div><div class="line">    th2.join();</div><div class="line">    th3.join();</div><div class="line">    std::cout &lt;&lt; <span class="string">"Sum :"</span> &lt;&lt; iSum &lt;&lt; std::endl;</div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="built_in">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中mutex就是一个互斥量，m.lock()就是加锁，m.unlock()就是释放锁，这样保证了iSum++每次只有一个线程在操作，运行结果每次都是30W。</p>
<p>临界区是一种比互斥量更严格的同步手段。在术语中，把获取临界区的锁成为进入临界区，释放临界区的锁成为离开临界区。临界区和 互斥量、信号量的区别在于：互斥量和信号量在整个系统的任何进程中都是可见的，换言之，一个进程创建了一个互斥量或者信号量，另一个进程获取该互斥量或者信号量是合法的；而临界区的作用范围仅限于本线程。除此之外，性质相同。</p>
<p>读写锁：读写锁有两种获取方式：共享式（读）和独占式（写）。</p>
<p>条件变量的意思是一个线程可以指定一个条件变量，然后等待这个条件的发生来触发线程。如果没有达到条件，线程就处于等待的状态，如果条件发生了就唤醒处于等待状态中的线程。当然，一个条件变量可以被多个线程等待，条件满足时也可以唤醒多个线程。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;iostream&gt;</span></div><div class="line"><span class="comment">#include &lt;thread&gt;</span></div><div class="line"><span class="comment">#include &lt;mutex&gt;</span></div><div class="line">long iSum = <span class="number">0</span>;</div><div class="line">std::mutex m;   <span class="regexp">//互斥量</span></div><div class="line">std::condition_variable cv; //定义一个条件变量</div><div class="line"><span class="literal">void</span> test_mutex()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</div><div class="line">    &#123;</div><div class="line">        m.lock();</div><div class="line">        iSum++;</div><div class="line">        m.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="literal">void</span> condition()</div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; <span class="string">"th4 is waiting sum == 300000"</span> &lt;&lt; std::endl;</div><div class="line">    std::unique_lock&lt;std::mutex&gt; lock&#123;m&#125;;</div><div class="line">    cv.wait<span class="function"><span class="params">(lock, []()-&gt;bool &#123;<span class="keyword">return</span> iSum == <span class="number">300000</span>;&#125;)</span>;</span></div><div class="line">    <span class="title">std</span>::<span class="title">cout</span> &lt;&lt; "<span class="title">th4</span> <span class="title">is</span> <span class="title">completed</span>!" &lt;&lt; <span class="title">std</span>::<span class="title">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="title">int</span> <span class="title">main</span><span class="params">()</span></div><div class="line">&#123;</div><div class="line">    <span class="title">std</span>::<span class="title">thread</span> <span class="title">th1</span><span class="params">(test_mutex)</span>, <span class="title">th2</span><span class="params">(test_mutex)</span>, <span class="title">th3</span><span class="params">(test_mutex)</span>;</div><div class="line">    <span class="title">std</span>::<span class="title">thread</span> <span class="title">th4</span><span class="params">(condition)</span>;</div><div class="line">    <span class="title">th1</span>.<span class="title">join</span><span class="params">()</span>;</div><div class="line">    <span class="title">th2</span>.<span class="title">join</span><span class="params">()</span>;</div><div class="line">    <span class="title">th3</span>.<span class="title">join</span><span class="params">()</span>;</div><div class="line">    <span class="title">cv</span>.<span class="title">notify_one</span><span class="params">()</span>;    ///满足条件的时候，通知<span class="title">th4</span>继续运行</div><div class="line">    <span class="title">th4</span>.<span class="title">join</span><span class="params">()</span>;</div><div class="line">    <span class="title">std</span>::<span class="title">cout</span> &lt;&lt; "<span class="title">Sum</span> :" &lt;&lt; <span class="title">iSum</span> &lt;&lt; <span class="title">std</span>::<span class="title">endl</span>;</div><div class="line">    <span class="title">system</span><span class="params">(<span class="string">"pause"</span>)</span>;</div><div class="line">    <span class="title">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在互斥量的基础之上添加了一个线程4以及线程4等待的条件，当iSum等于30W的时候，条件变量通知线程4继续运行。</p>
</div><div class="tags"></div><div class="post-nav"><a href="/2016/04/22/cplusplus-foundation-2/" class="pre">【C++基础】虚函数表</a><a href="/2016/03/23/ace-foundation-3/" class="next">【ACE基础】使用缓存式分配器</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://dabaizi.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/18/learn-algorithm-6/">【渣渣学算法6】Font Size</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/17/learn-algorithm-5/">【渣渣学算法5】Hangover</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/12/learn-algorithm-4/">【渣渣学算法4】487-3279</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/11/learn-algorithm-3/">【渣渣学算法3】Exponentiation</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/10/learn-algorithm-2/">【渣渣学算法2】最长回文子串</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/07/learn-algorithm-1/">【渣渣学算法1】之传话游戏</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/30/cplusplus-foundation-7/">【C++基础】矩阵模板类</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/29/cplusplus-foundation-6/">【C++基础】虚函数与继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/27/cplusplus-foundation-5/">【C++基础】const相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/26/cplusplus-foundation-4/">【C++基础】函数指针</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.aligugu.net/" title="阿里姑姑" target="_blank">阿里姑姑</a><ul></ul><a href="http://www.uxhr.com/" title="优秀hr" target="_blank">优秀hr</a><ul></ul><a href="http://www.example3.com/" title="米表" target="_blank">米表</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">博观约取 厚积薄发.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>